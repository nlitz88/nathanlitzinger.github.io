<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>MIPS Mini CPU - 5 Stage Pipeline in Verilog | Nathan Litzinger</title>
<meta name=keywords content>
<meta name=description content="As a conclusion to my computer organization course, our final project was to implement a five stage pipeline constructed in Verilog over an FPGA partially implementing the MIPS instruction set.
Abstract The following details the development of a five stage pipeline constructed on Xilinx&rsquo;s Vivado in Verilog over an FPGA partially implementing the MIPS instruction set. In its current configuration, it supports only basic R-Format instructions like add, sub, and, or, etc.">
<meta name=author content="Nathan Litzinger">
<link rel=canonical href=https://nlitz88.github.io/projects/mipscpu/mipscpu/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nlitz88.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://nlitz88.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://nlitz88.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://nlitz88.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://nlitz88.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.1">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="MIPS Mini CPU - 5 Stage Pipeline in Verilog">
<meta property="og:description" content="As a conclusion to my computer organization course, our final project was to implement a five stage pipeline constructed in Verilog over an FPGA partially implementing the MIPS instruction set.
Abstract The following details the development of a five stage pipeline constructed on Xilinx&rsquo;s Vivado in Verilog over an FPGA partially implementing the MIPS instruction set. In its current configuration, it supports only basic R-Format instructions like add, sub, and, or, etc.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nlitz88.github.io/projects/mipscpu/mipscpu/"><meta property="og:image" content="https://nlitz88.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="projects">
<meta property="article:published_time" content="2021-05-01T14:31:00-04:00">
<meta property="article:modified_time" content="2021-05-01T14:31:00-04:00"><meta property="og:site_name" content="Nathan Litzinger">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://nlitz88.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="MIPS Mini CPU - 5 Stage Pipeline in Verilog">
<meta name=twitter:description content="As a conclusion to my computer organization course, our final project was to implement a five stage pipeline constructed in Verilog over an FPGA partially implementing the MIPS instruction set.
Abstract The following details the development of a five stage pipeline constructed on Xilinx&rsquo;s Vivado in Verilog over an FPGA partially implementing the MIPS instruction set. In its current configuration, it supports only basic R-Format instructions like add, sub, and, or, etc.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://nlitz88.github.io/projects/"},{"@type":"ListItem","position":2,"name":"MIPS Mini CPU - 5 Stage Pipeline in Verilog","item":"https://nlitz88.github.io/projects/mipscpu/mipscpu/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MIPS Mini CPU - 5 Stage Pipeline in Verilog","name":"MIPS Mini CPU - 5 Stage Pipeline in Verilog","description":"As a conclusion to my computer organization course, our final project was to implement a five stage pipeline constructed in Verilog over an FPGA partially implementing the MIPS instruction set.\nAbstract The following details the development of a five stage pipeline constructed on Xilinx\u0026rsquo;s Vivado in Verilog over an FPGA partially implementing the MIPS instruction set. In its current configuration, it supports only basic R-Format instructions like add, sub, and, or, etc.","keywords":[],"articleBody":"As a conclusion to my computer organization course, our final project was to implement a five stage pipeline constructed in Verilog over an FPGA partially implementing the MIPS instruction set.\nAbstract The following details the development of a five stage pipeline constructed on Xilinx’s Vivado in Verilog over an FPGA partially implementing the MIPS instruction set. In its current configuration, it supports only basic R-Format instructions like add, sub, and, or, etc. as well as basic I-Format instructions like lw and sw. Additionally, in this final revision of the pipeline, data forwarding to the instruction decode stage was implemented along with write-back of the register file on the negative edge of the clock both in order to reduce the penalty for data hazards. It achieves this functionality by making use of five pipeline registers, a control unit, an ALU, a number of multiplexors, dedicated memories for instructions and data, and a register file.\nIntroduction This simple MIPS pipeline implementation begins with the first pipeline register, the instruction memory, and a 32-bit adder that all make up the instruction fetch stage. In this simple implementation, the program counter register (the first pipeline register) has only a single input, which is its current value + 4. If the design were extended to support branch and jump instructions, this input would be equipped instead with a multiplexer to control where in the program execution jumped to next. The current PC value is used to select the corresponding instruction from the instruction memory, and this instruction is set up on the input of the IF/ID pipeline register.\nThe next stage that the instruction enters once it has been written to the IF/ID register is the instruction decode stage. In this implementation, this stage is where, using the encoded instruction, the instruction’s control signals are initially generated by the control unit, where the immediate field of the instruction is sign-extended, where the destination register is selected for later use, and where the instruction operands are selected and read from the register file. Data is also written back to the register file in this stage on the negative edge of the clock if a “wreg” signal is asserted by the instruction in the write-back stage (more on this later). This stage also includes the logic that enables forwarding to this stage, which will be discussed in more detail later.\nOnce the instruction has effectively been interpreted in the ID stage, and once its control signals and operands are written to the next pipeline register, the ID/EXE register, the instruction is in the execution stage. It is in this stage where the ALU produces the result of R-Format instructions and the memory addresses for lw and sw instructions. Depending on the type on instruction, the second ALU operand will be selected to produce the desired result. If a lw or sw, the immediate containing the offset is selected, whereas the second operand read from the register file (“qb”) will be selected for an R-Format instruction. Note that “qb” is passed to the next stage as well in case of a sw instruction, as it will be the data to be stored.\nWhen the ALU result and other signals have been written to the fourth pipeline register, the EXE/MEM register, the instruction is in the memory stage. In this stage, data can be read from memory at the target address calculated by the ALU in the previous stage, or data (“qb”) can written to the data memory at that target address if a “wmem” signal is asserted, indicating that the instruction in this stage is to write to memory (i.e., a sw). R-Format instructions, on the other hand, simply pass through this stage, with the ALU result making its way to next pipeline stage.\nAn instruction is in the fifth and final stage of this pipeline once it has been written to the MEM/WB pipeline register. This stage is simply comprised of the MEM/WB register, a multiplexor to select the data source for the instruction’s write, and essentially shares the register file with the instruction decode stage. This “sharing” does not lead to a physical hazard, however, because instructions in both stages interact with different ports.\nThe result is a functioning five stage pipeline that looks something like this:\nHowever, some improvements can be made. Consider the following instruction sequence:\nWithout any changes, the more primitive design would incur a significant stall penalty due to the lack of availability of the result to be stored in register $3. Thus, the final portion of this project was dedicated to implementing a means of data-forwarding. Before discussing the approach to forwarding employed, a simple change was also introduced in the register file that allows it to write data on the negative edge of the clock. While this improvement does not solve all of the data hazards, it does mitigate some and also reduces the need for forwarding in many cases. Because an instruction currently in the write-back stage can write its data on the negative edge of the clock signal, this means that an instruction currently in the decode stage that depends on the result of that instruction in the write-back stage can obtain the correct data from that common register without requiring any forwarding, as it reads asynchronously for the duration of the clock cycle. For introducing forwarding, while different approaches exist and each offer unique advantages, the approach employed in this project was to implement forwarding to the instruction decode stage from both the execution stage and memory stage.\nIn this approach, data hazards between instructions can all be resolved within the decode stage. This means that no additional forwarding is needed to the execution stage, as if there was a data hazard when the instruction was being decoded, it would have been forwarded the correct data at that point. Of course, a stall is still needed in the instance of a load-use data hazard, but for the hazards between R-Format instructions, this method is ideal. An additional advantage that this method has is that it inherently also supports forwarding needed for branch data-hazards. It is common to relocate the evaluation of branch conditions to the ID stage, and therefore sometimes forwarding is needed to obtain the correct operands. In this way, because the forwarding hardware is already implemented in the ID stage for other types of instructions, additional (forwarding) hardware is not needed for branch instructions. To implement forwarding in this manner, two 32-bit 4 to 1 multiplexers needed to placed before the ID/EXE pipeline register. These multiplexers would be responsible selecting the appropriate source for the needed operand each using their own 2-bit select signal generated by the control unit. In this way, the control unit (which the forwarding unit has effectively been built into) determines if a data-hazard is present, and if so, generates the necessary selection signals to get the necessary data to the right spot in the decode stage.\nTo detect when a data hazard occurs, the control unit had to be outfitted with a few additional inputs: ewreg, ern, mwreg, mm2reg, and mrn (note that em2reg is also added, but is only used to detect if the instruction in the execution stage is a lw instruction, which can be used for identifying load-use data hazards in slightly more sophisticated implementations). Then, the logic used to identify data hazards within the control unit was as follows:\n If the rs register number of the instruction in the ID stage matches the destination register number (ern) of the instruction in the EXE stage, AND the instruction in the EXE stage will eventually write back to the register file (indicated by ewreg being HIGH), then the data read from the register file is out of date, so select the data from the output of the ALU to be written to ID/EXE as the operand. If the rs register number of the instruction in the ID stage matches the destination register number (mrn) of the instruction in the MEM stage, AND the instruction in the MEM stage will eventually write back to the register file (indicated by mwreg being HIGH), then:  If mm2reg low, this indicates that the ALU result will eventually be written back to the register file, and therefore the ALU result from the MEM stage should be forwarded to the ID stage, so select it to be written to ID/EXE as the rs operand. If mm2reg is HIGH, this indicates that the data output of the data memory will eventually be selected to be written back to the register file, and therefore the data output (do) should be forwarded to the ID stage, so select it to be written to ID/EXE as the rs operand. Likewise, the same logic is implemented but making the comparisons with the “rt” register number.    To actually solve the data hazards, the control unit has two additional outputs. Each is the 2-bit selection signal used to choose one of the four potential sources for each forwarding multiplexer. In this way, data hazards can effectively be detected and solved. Also, note that when one of the operand’s register numbers matches that of multiple earlier instructions that occurred immediately before it, such that they are still in the EXE and MEM stage, it implicitly works out that the most recent instruction with that destination will have its data forwarded. This is detailed in the source code.\nOnce the forwarding hardware is introduced, the resulting pipeline looks something like this:\n","wordCount":"1578","inLanguage":"en","datePublished":"2021-05-01T14:31:00-04:00","dateModified":"2021-05-01T14:31:00-04:00","author":{"@type":"Person","name":"Nathan Litzinger"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nlitz88.github.io/projects/mipscpu/mipscpu/"},"publisher":{"@type":"Organization","name":"Nathan Litzinger","logo":{"@type":"ImageObject","url":"https://nlitz88.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://nlitz88.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://nlitz88.github.io/litzingernathanresume.pdf title=Resume>
<span>Resume</span>
</a>
</li>
<li>
<a href=https://nlitz88.github.io/projects title=Projects>
<span>Projects</span>
</a>
</li>
<li>
<a href=https://nlitz88.github.io/posts title=Posts>
<span>Posts</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://nlitz88.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://nlitz88.github.io/projects/>Projects</a></div>
<h1 class=post-title>
MIPS Mini CPU - 5 Stage Pipeline in Verilog
</h1>
<div class=post-meta>May 1, 2021&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Nathan Litzinger&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/projects/mipscpu/mipscpu.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><p>As a conclusion to my computer organization course, our final project was to implement a five stage pipeline constructed in Verilog over an FPGA partially implementing the MIPS instruction set.</p>
<h2 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h2>
<p>The following details the development of a five stage pipeline constructed on Xilinx&rsquo;s Vivado in Verilog over an FPGA partially implementing the MIPS instruction set. In its current configuration, it supports only basic R-Format instructions like add, sub, and, or, etc. as well as basic I-Format instructions like lw and sw. Additionally, in this final revision of the pipeline, data forwarding to the instruction decode stage was implemented along with write-back of the register file on the negative edge of the clock both in order to reduce the penalty for data hazards. It achieves this functionality by making use of five pipeline registers, a control unit, an ALU, a number of multiplexors, dedicated memories for instructions and data, and a register file.</p>
<h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2>
<p>This simple MIPS pipeline implementation begins with the first pipeline register, the instruction memory, and a 32-bit adder that all make up the instruction fetch stage. In this simple implementation, the program counter register (the first pipeline register) has only a single input, which is its current value + 4. If the design were extended to support branch and jump instructions, this input would be equipped instead with a multiplexer to control where in the program execution jumped to next. The current PC value is used to select the corresponding instruction from the instruction memory, and this instruction is set up on the input of the IF/ID pipeline register.</p>
<p>The next stage that the instruction enters once it has been written to the IF/ID register is the instruction decode stage. In this implementation, this stage is where, using the encoded instruction, the instruction’s control signals are initially generated by the control unit, where the immediate field of the instruction is sign-extended, where the destination register is selected for later use, and where the instruction operands are selected and read from the register file. Data is also written back to the register file in this stage on the negative edge of the clock if a “wreg” signal is asserted by the instruction in the write-back stage (more on this later). This stage also includes the logic that enables forwarding to this stage, which will be discussed in more detail later.</p>
<p>Once the instruction has effectively been interpreted in the ID stage, and once its control signals and operands are written to the next pipeline register, the ID/EXE register, the instruction is in the execution stage. It is in this stage where the ALU produces the result of R-Format instructions and the memory addresses for lw and sw instructions. Depending on the type on instruction, the second ALU operand will be selected to produce the desired result. If a lw or sw, the immediate containing the offset is selected, whereas the second operand read from the register file (“qb”) will be selected for an R-Format instruction. Note that “qb” is passed to the next stage as well in case of a sw instruction, as it will be the data to be stored.</p>
<p>When the ALU result and other signals have been written to the fourth pipeline register, the EXE/MEM register, the instruction is in the memory stage. In this stage, data can be read from memory at the target address calculated by the ALU in the previous stage, or data (“qb”) can written to the data memory at that target address if a “wmem” signal is asserted, indicating that the instruction in this stage is to write to memory (i.e., a sw). R-Format instructions, on the other hand, simply pass through this stage, with the ALU result making its way to next pipeline stage.</p>
<p>An instruction is in the fifth and final stage of this pipeline once it has been written to the MEM/WB pipeline register. This stage is simply comprised of the MEM/WB register, a multiplexor to select the data source for the instruction’s write, and essentially shares the register file with the instruction decode stage. This “sharing” does not lead to a physical hazard, however, because instructions in both stages interact with different ports.</p>
<p>The result is a functioning five stage pipeline that looks something like this:</p>
<p><img loading=lazy src=/projects/mipscpu/pipeline1.png alt="alt text">
</p>
<p>However, some improvements can be made. Consider the following instruction sequence:</p>
<p><img loading=lazy src=/projects/mipscpu/instructions.png alt="alt text">
</p>
<p>Without any changes, the more primitive design would incur a significant stall penalty due to the lack of availability of the result to be stored in register $3. Thus, the final portion of this project was dedicated to implementing a means of data-forwarding.
Before discussing the approach to forwarding employed, a simple change was also introduced in the register file that allows it to write data on the negative edge of the clock. While this improvement does not solve all of the data hazards, it does mitigate some and also reduces the need for forwarding in many cases. Because an instruction currently in the write-back stage can write its data on the negative edge of the clock signal, this means that an instruction currently in the decode stage that depends on the result of that instruction in the write-back stage can obtain the correct data from that common register without requiring any forwarding, as it reads asynchronously for the duration of the clock cycle.
For introducing forwarding, while different approaches exist and each offer unique advantages, the approach employed in this project was to implement forwarding to the instruction decode stage from both the execution stage and memory stage.</p>
<p>In this approach, data hazards between instructions can all be resolved within the decode stage. This means that no additional forwarding is needed to the execution stage, as if there was a data hazard when the instruction was being decoded, it would have been forwarded the correct data at that point. Of course, a stall is still needed in the instance of a load-use data hazard, but for the hazards between R-Format instructions, this method is ideal. An additional advantage that this method has is that it inherently also supports forwarding needed for branch data-hazards. It is common to relocate the evaluation of branch conditions to the ID stage, and therefore sometimes forwarding is needed to obtain the correct operands. In this way, because the forwarding hardware is already implemented in the ID stage for other types of instructions, additional (forwarding) hardware is not needed for branch instructions.
To implement forwarding in this manner, two 32-bit 4 to 1 multiplexers needed to placed before the ID/EXE pipeline register. These multiplexers would be responsible selecting the appropriate source for the needed operand each using their own 2-bit select signal generated by the control unit. In this way, the control unit (which the forwarding unit has effectively been built into) determines if a data-hazard is present, and if so, generates the necessary selection signals to get the necessary data to the right spot in the decode stage.</p>
<p>To detect when a data hazard occurs, the control unit had to be outfitted with a few additional inputs: ewreg, ern, mwreg, mm2reg, and mrn (note that em2reg is also added, but is only used to detect if the instruction in the execution stage is a lw instruction, which can be used for identifying load-use data hazards in slightly more sophisticated implementations). Then, the logic used to identify data hazards within the control unit was as follows:</p>
<ul>
<li>If the rs register number of the instruction in the ID stage matches the destination register number (ern) of the instruction in the EXE stage, AND the instruction in the EXE stage will eventually write back to the register file (indicated by ewreg being HIGH), then the data read from the register file is out of date, so select the data from the output of the ALU to be written to ID/EXE as the operand.</li>
<li>If the rs register number of the instruction in the ID stage matches the destination register number (mrn) of the instruction in the MEM stage, AND the instruction in the MEM stage will eventually write back to the register file (indicated by mwreg being HIGH), then:
<ul>
<li>If mm2reg low, this indicates that the ALU result will eventually be written back to the register file, and therefore the ALU result from the MEM stage should be forwarded to the ID stage, so select it to be written to ID/EXE as the rs operand.</li>
<li>If mm2reg is HIGH, this indicates that the data output of the data memory will eventually be selected to be written back to the register file, and therefore the data output (do) should be forwarded to the ID stage, so select it to be written to ID/EXE as the rs operand.
Likewise, the same logic is implemented but making the comparisons with the “rt” register number.</li>
</ul>
</li>
</ul>
<p>To actually solve the data hazards, the control unit has two additional outputs. Each is the 2-bit selection signal used to choose one of the four potential sources for each forwarding multiplexer. In this way, data hazards can effectively be detected and solved.
Also, note that when one of the operand’s register numbers matches that of multiple earlier instructions that occurred immediately before it, such that they are still in the EXE and MEM stage, it implicitly works out that the most recent instruction with that destination will have its data forwarded. This is detailed in the source code.</p>
<p>Once the forwarding hardware is introduced, the resulting pipeline looks something like this:</p>
<p><img loading=lazy src=/projects/mipscpu/pipeline2.png alt="alt text">
</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://nlitz88.github.io/projects/filesystem/filesystem/>
<span class=title>« Prev Page</span>
<br>
<span>FS3 - My Mock File System</span>
</a>
<a class=next href=https://nlitz88.github.io/projects/2020leds/2020leds/>
<span class=title>Next Page »</span>
<br>
<span>My First QuinLED Dig Uno Project</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://nlitz88.github.io/>Nathan Litzinger</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>